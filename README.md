1.malloc的相关问题
int * p = (int *)malloc(sizeof(int))
1.	int * p:
o	int * 表示这是一个指向 int 类型的指针。
o	p 是指针变量的名字。这意味着 p 可以保存一个地址，这个地址指向一个 int 类型的变量。
2.	malloc(sizeof(int)):
o	malloc 是标准库函数，用于动态分配内存。它的全称是 "memory allocation"（内存分配）。
o	sizeof(int) 返回 int 类型在内存中占用的字节数。通常，这个值在不同的平台上可能会有所不同，但在大多数系统中，它是 4。
o	malloc(sizeof(int)) 表示我们向系统请求分配足够存储一个 int 类型变量的内存空间。
3.	(int *):
o	malloc 返回的值是 void * 类型，表示通用指针，可以指向任何类型的变量。
o	(int *) 是类型转换，将 void * 类型的指针转换为 int * 类型的指针，这样我们就可以将它赋值给 p 变量。
4.	合在一起:
o	int * p = (int *)malloc(sizeof(int)); 这行代码的完整意思是：分配足够存储一个 int 类型变量的内存空间，并将该内存空间的地址赋值给指针变量 p。
简而言之，这行代码的作用是为一个 int 类型变量动态分配内存，并使用指针 p 来引用这块内存。这在需要动态内存管理的情况下非常有用，比如数组大小在运行时才确定，或者需要分配大量内存而不希望使用栈上的固定内存空间。
通俗解释：
想象一下你在一个房间里（计算机内存）。你需要一个抽屉来存放一个整数（int 类型）。但是房间里没有合适的抽屉（没有足够的固定内存）。于是你打电话给管理人员（使用 malloc 函数），告诉他们你需要一个能存放整数大小的抽屉（sizeof(int) 返回整数所需的空间大小）。管理人员为你找到了一个合适的抽屉，并告诉你这个抽屉的位置（返回内存地址）。你把这个位置记在一个笔记本上（指针 p），这样你以后就能找到这个抽屉，并把整数放进去或取出来。
这个过程就是动态内存分配，p 就是你记下抽屉位置的笔记本，它帮助你在需要的时候找到那个抽屉。
4o
 
2.pArr
在C语言中，pArr通常表示一个指向数组（array）的指针（pointer）。这是约定俗成的命名习惯，p表示指针（pointer），Arr表示数组（array），合起来就是指向数组的指针


3.下标与指针的关系
在C语言中，数组和指针的关系密切。表达式 p[i] 和 *(p + i) 之间的等价性是基于指针算术和数组访问的机制。我们将详细解释这种等价性。
数组和指针的基本概念
•	数组名作为指针：在C语言中，数组名本质上是一个指向数组第一个元素的指针。例如，int a[5] 中，a 是指向 a[0] 的指针，类型为 int*。
•	指针算术：指针可以进行算术运算。例如，p + i 计算的是指针 p 指向的地址加上 i 个元素后的地址。如果 p 是 int* 类型，则 p + i 实际上是 p 加上 i * sizeof(int)。
等价性解释
1. 指针和数组的关系
假设有一个数组 int a[5]：
c
复制代码
int a[5] = {1, 2, 3, 4, 5};
数组 a 可以看作是指向数组第一个元素 a[0] 的指针。因此，a 和 &a[0] 是等价的，都是指向 a[0] 的地址。
2. 数组下标访问
数组元素可以通过下标访问：
c
复制代码
int value = a[i];
在这里，a[i] 表示数组 a 中第 i 个元素。
3. 指针解引用访问
指针解引用也可以用来访问数组元素：
c
复制代码
int value = *(a + i);
在这里，a + i 计算的是数组 a 的起始地址加上 i 个 int 大小后的地址，然后通过 * 运算符解引用该地址，得到第 i 个元素的值。
4. 等价性证明
通过以上两种方式访问数组元素是等价的，a[i] 等价于 *(a + i)：
•	a 是指向 a[0] 的指针。
•	a + i 是 a 的起始地址加上 i 个 int 大小后的地址。
•	*(a + i) 是解引用该地址，得到第 i 个元素的值。
因此，a[i] 实际上就是编译器帮我们做的指针算术 *(a + i)。
例子
让我们通过一个例子进一步说明这种等价性：
c
复制代码
#include <stdio.h>

int main(void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int i;

    for (i = 0; i < 5; ++i)
    {
        printf("a[%d] = %d; *(a + %d) = %d\n", i, a[i], i, *(a + i));
    }

    return 0;
}
输出结果：
css
复制代码
a[0] = 1; *(a + 0) = 1
a[1] = 2; *(a + 1) = 2
a[2] = 3; *(a + 2) = 3
a[3] = 4; *(a + 3) = 4
a[4] = 5; *(a + 4) = 5
在这个例子中，我们展示了使用 a[i] 和 *(a + i) 访问数组元素，结果是相同的。
结论
p[i] 永远等价于 *(p + i) 是因为：
•	数组名是指向数组第一个元素的指针。
•	数组下标运算符 [] 本质上是通过指针算术和解引用来实现的。
•	p[i] 就是 *(p + i)，即指针 p 加上偏移量 i 后的地址，通过解引用获取该地址处的值。
这种等价性是C语言中数组和指针紧密关系的体现。理解这一点可以帮助我们更好地理解和使用数组和指针。
4o
解释一下&a[i]为什么等价于a+i
ChatGPT
在C语言中，&a[i] 和 a + i 是等价的。这种等价性来源于数组和指针的关系及其运算规则。我们可以从以下几个方面来详细解释这一点。
数组和指针的基本概念
1.	数组名作为指针：
o	数组名本质上是一个指向数组第一个元素的指针。例如，int a[5] 中，a 是一个指向 a[0] 的指针，类型为 int*。
2.	指针算术：
o	指针可以进行算术运算。例如，a + i 计算的是指针 a 指向的地址加上 i 个元素后的地址。如果 a 是 int* 类型，则 a + i 实际上是 a 加上 i * sizeof(int)。
等价性解释
1. 数组下标和指针
假设有一个数组 int a[5]：
c
复制代码
int a[5] = {1, 2, 3, 4, 5};
数组 a 可以看作是指向数组第一个元素 a[0] 的指针。因此，a 和 &a[0] 是等价的，都是指向 a[0] 的地址。
2. 取数组元素地址
要获取数组元素 a[i] 的地址，可以使用取地址操作符 &：
c
复制代码
int* p = &a[i];
在这里，&a[i] 表示获取数组 a 中第 i 个元素的地址。
3. 指针算术
通过指针算术，也可以计算出数组 a 中第 i 个元素的地址：
c
复制代码
int* p = a + i;
在这里，a + i 计算的是数组 a 的起始地址加上 i 个 int 大小后的地址。
等价性证明
&a[i] 和 a + i 是等价的，因为它们计算出的地址相同：
•	a 是指向 a[0] 的指针。
•	a + i 是 a 的起始地址加上 i 个 int 大小后的地址。
•	&a[i] 也是计算出数组 a 中第 i 个元素的地址。
通过这两种方式计算出的地址是相同的，因此它们是等价的。
例子
让我们通过一个例子进一步说明这种等价性：
c
复制代码
#include <stdio.h>

int main(void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int i;

    for (i = 0; i < 5; ++i)
    {
        printf("&a[%d] = %p; a + %d = %p\n", i, (void*)&a[i], i, (void*)(a + i));
    }

    return 0;
}
输出结果：
css
复制代码
&a[0] = 0x7ffcc3b9c5b0; a + 0 = 0x7ffcc3b9c5b0
&a[1] = 0x7ffcc3b9c5b4; a + 1 = 0x7ffcc3b9c5b4
&a[2] = 0x7ffcc3b9c5b8; a + 2 = 0x7ffcc3b9c5b8
&a[3] = 0x7ffcc3b9c5bc; a + 3 = 0x7ffcc3b9c5bc
&a[4] = 0x7ffcc3b9c5c0; a + 4 = 0x7ffcc3b9c5c0
在这个例子中，我们展示了使用 &a[i] 和 a + i 计算数组元素的地址，结果是相同的。
结论
&a[i] 等价于 a + i 是因为：
•	数组名是指向数组第一个元素的指针。
•	取数组元素的地址 &a[i] 实际上是计算数组起始地址加上 i 个元素后的地址。
•	指针算术 a + i 直接计算出相同的地址。
这种等价性是C语言中数组和指针紧密关系的体现。理解这一点可以帮助我们更好地理解和使用数组和指针。
4o
void Inputstudent (struct student &st)

4. 有关对齐“为啥printf("%d\n", sizeof(st));输出是108而不是105”
#include <stdio.h>
#include <string.h>

struct Student {
    int age;       // 4 bytes
    char sex;      // 1 byte
    char name[100]; // 100 bytes
}; // 分号不能省

void InputStudent(struct Student *);
void OutputStudent(struct Student *);

int main(void) {
    struct Student st;  // 15行
    printf("%d\n", sizeof(st));  // 输出108

    InputStudent(&st);  // 对结构体变量输入，必须发送st的地址
    OutputStudent(&st); // 对结构体变量输出，可以发送st的地址也可以直接发送st的内容，但为了减少内存的耗费，也为了提高执行速度，推荐发送地址

    return 0;
原因解释：
那多的3个为填充空白，
比喻：停车场
每一个字符类型都必须符合自身的规则，其编号必须是自身大小的倍数（整数）
第三个车 name：

这是一辆大巴，需要100个车位。它需要从编号是4的倍数的车位开始停车。所以它得从第8个车位开始（因为前面有4个车位+1个车位，还有2个空车位才凑满4的倍数）。
为了让大巴从第8个车位开始停车，停车场在第5个车位后面填充了3个空车位。
车位编号：[1][2][3][4][5][空][空][空][8][9]...[107]
这个比喻中的车位就是内存地址：

age占4个车位，从地址0到3。
sex占1个车位，从地址4。
填充3个车位，从地址5到7（为了对齐name）。
name占100个车位，从地址8到107。

